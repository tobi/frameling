#!/bin/bash
set -eEo pipefail

# Apply script for frameling configuration
# Symlinks files from _* directories to corresponding $HOME locations with _ -> .
#
# Directory naming conventions:
#   _config/foo/     - Individual file symlinks (each file symlinked separately)
#   _config/foo$/    - Folder symlink (entire directory symlinked as one unit)

FRAMELING_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DRY_RUN=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            echo "Usage: $0 [--dry-run]"
            exit 1
            ;;
    esac
done

if $DRY_RUN; then
    echo "DRY RUN MODE - No changes will be made"
    echo
fi

# Step 0: Run all scripts in scripts/ directory
SCRIPTS_DIR="$FRAMELING_DIR/scripts"
if [[ -d "$SCRIPTS_DIR" ]]; then
    for script in "$SCRIPTS_DIR"/*.sh; do
        [[ -f "$script" ]] || continue
        if $DRY_RUN; then
            echo "RUN   $script"
        else
            echo "Running $script..."
            bash "$script"
        fi
    done
    $DRY_RUN && echo
fi

# Step 1: Get all files in _* directories
FILES=()
while IFS= read -r -d '' file; do
    FILES+=("$file")
done < <(find "$FRAMELING_DIR" -path "*/_*" -type f -print0)

# Step 2 & 3: Build list of symlink operations
declare -A OPERATIONS  # target -> source

for file in "${FILES[@]}"; do
    # Get relative path from frameling dir
    relative="${file#$FRAMELING_DIR/}"

    # Transform leading _ to .
    target_relative="${relative/_/.}"

    # Check if path contains $/ (folder symlink marker)
    if [[ "$target_relative" == *'$/'* ]]; then
        # Folder symlink: strip everything from $ onwards
        target_relative="${target_relative%%\$/*}"
        source_relative="${relative%%\$/*}\$"
        source_path="$FRAMELING_DIR/$source_relative"
    else
        # Regular file symlink
        source_path="$file"
    fi

    target_path="$HOME/$target_relative"

    # Store operation (automatically dedupes via associative array)
    OPERATIONS["$target_path"]="$source_path"
done

# Step 4: Sort targets and identify folder symlink targets
SORTED_TARGETS=($(printf '%s\n' "${!OPERATIONS[@]}" | sort))

# Build set of folder symlink targets (to exclude from mkdir)
declare -A FOLDER_SYMLINKS
for target in "${SORTED_TARGETS[@]}"; do
    source="${OPERATIONS[$target]}"
    if [[ -d "$source" ]]; then
        FOLDER_SYMLINKS["$target"]=1
    fi
done

# Collect needed parent directories (excluding folder symlink targets)
# Also track broken symlinks that need to be removed
declare -A NEEDED_DIRS
declare -A BROKEN_SYMLINKS
for target in "${SORTED_TARGETS[@]}"; do
    target_dir="$(dirname "$target")"
    # Walk up the tree, creating parents as needed
    while [[ "$target_dir" != "$HOME" && "$target_dir" != "/" ]]; do
        # Don't create directory if it's a folder symlink target
        if [[ ${FOLDER_SYMLINKS["$target_dir"]} ]]; then
            break
        fi
        if [[ -L "$target_dir" && ! -e "$target_dir" ]]; then
            # Broken symlink - needs to be removed and directory created
            BROKEN_SYMLINKS["$target_dir"]=1
            NEEDED_DIRS["$target_dir"]=1
        elif [[ ! -d "$target_dir" && ! -L "$target_dir" ]]; then
            NEEDED_DIRS["$target_dir"]=1
        fi
        target_dir="$(dirname "$target_dir")"
    done
done

# Create needed directories first (removing broken symlinks if necessary)
for dir in $(printf '%s\n' "${!NEEDED_DIRS[@]}" | sort); do
    if [[ ${BROKEN_SYMLINKS["$dir"]} ]]; then
        if $DRY_RUN; then
            echo "RM    [broken] $dir -> $(readlink "$dir")"
        else
            rm "$dir"
        fi
    fi
    if $DRY_RUN; then
        echo "MKDIR $dir"
    else
        mkdir -p "$dir"
    fi
done

# Step 5: Process symlink operations
for target in "${SORTED_TARGETS[@]}"; do
    source="${OPERATIONS[$target]}"

    # Determine operation type for display
    if [[ -d "$source" ]]; then
        op_type="dir"
    else
        op_type="file"
    fi

    # Check current state
    if [[ -L "$target" ]]; then
        current="$(readlink "$target")"
        if [[ "$current" == "$source" ]]; then
            if $DRY_RUN; then
                echo "OK    [$op_type] $target"
            fi
            continue
        else
            if $DRY_RUN; then
                echo "FIX   [$op_type] $target -> $source"
                echo "      (currently -> $current)"
            else
                rm "$target"
                ln -s "$source" "$target"
                echo "Fixed: $target -> $source"
            fi
        fi
    elif [[ -e "$target" ]]; then
        # Something exists that's not a symlink
        backup="${target}_backup_$(date +%s)"
        if $DRY_RUN; then
            echo "MOVE  [$op_type] $target -> $backup"
            echo "LINK  [$op_type] $target -> $source"
        else
            mv "$target" "$backup"
            ln -s "$source" "$target"
            echo "Backed up $target to $backup"
            echo "Created: $target -> $source"
        fi
    else
        # Nothing exists, create symlink
        if $DRY_RUN; then
            echo "LINK  [$op_type] $target -> $source"
        else
            ln -s "$source" "$target"
            echo "Created: $target -> $source"
        fi
    fi
done

if $DRY_RUN; then
    echo
    echo "DRY RUN COMPLETE - No changes made"
else
    echo "Apply complete"
fi